{"version":3,"sources":["webpack://webpack-configuration/./src/ts/utils/getters/getIPClass.ts","webpack://webpack-configuration/./src/ts/utils/converters/binToDec.ts","webpack://webpack-configuration/./src/ts/utils/getters/getAffectedOctetsIndexFromMask.ts","webpack://webpack-configuration/./src/ts/utils/calculations/nearestMultiple.ts","webpack://webpack-configuration/./src/ts/utils/calculations/modifyIPViaMask.ts","webpack://webpack-configuration/./src/ts/utils/calculations/calculateBroadcastAddress.ts","webpack://webpack-configuration/./src/ts/utils/calculations/calculateHosts.ts","webpack://webpack-configuration/./src/ts/utils/calculations/calculateLastHostAddress.ts","webpack://webpack-configuration/./src/ts/utils/calculations/calculateNetworkAddress.ts","webpack://webpack-configuration/./src/ts/utils/calculations/calculateData.ts","webpack://webpack-configuration/./src/ts/utils/general/checkMaskToIPValidity.ts","webpack://webpack-configuration/./src/ts/utils/converters/decToBin.ts","webpack://webpack-configuration/./src/ts/utils/general/parseIP.ts","webpack://webpack-configuration/./src/ts/utils/general/parseURLParams.ts","webpack://webpack-configuration/./src/ts/utils/getters/getMaskFromBits.ts","webpack://webpack-configuration/./src/ts/utils/getters/getUserIP.ts","webpack://webpack-configuration/./src/ts/utils/getters/getParams.ts","webpack://webpack-configuration/./src/ts/utils/getters/getAddressPublicState.ts","webpack://webpack-configuration/./src/ts/utils/ui/updateAdditionalInfoUI.ts","webpack://webpack-configuration/./src/ts/utils/getters/getContainerForAddress.ts","webpack://webpack-configuration/./src/ts/utils/general/removeAllChildNodes.ts","webpack://webpack-configuration/./src/ts/utils/ui/populateElementWithOctets.ts","webpack://webpack-configuration/./src/ts/utils/ui/updateBinaryUI.ts","webpack://webpack-configuration/./src/ts/utils/ui/updateDecimalUI.ts","webpack://webpack-configuration/./src/ts/utils/ui/updateEnteredDataUI.ts","webpack://webpack-configuration/./src/ts/utils/ui/updateUI.ts","webpack://webpack-configuration/./src/ts/calculator.ts"],"names":["ip","firstOctetDec","decimal","octets","bin","parseInt","mask","bits","num","multiple","Math","ceil","modifyWithBit","ipObject","binary","string","affectedOctetsFromIndex","affectedOctetsBin","filter","_o","i","closestOctetEnd","affectedSinceBit","affectedOctetsBinWithChanges","map","octet","index","split","bit","join","repeat","octetsWithChanges","concat","octetsWithChangesDec","octetsWithChangesString","octetsWithChangesDecString","referenceAddress","type","lastOctetAsArray","lastOctetWithChanges","o","broadcast","network","amountOfHosts","ipClass","maxHost","minHost","validity","valid","reason","maskBits","dec","toString","checkForErrors","ipOctets","rawIpOctets","errorString","Number","isNaN","Error","ipString","Promise","ipOctetsBin","padStart","url","location","href","question","indexOf","hash","length","query","substring","result","forEach","part","eq","key","substr","val","decodeURIComponent","from","to","push","fetch","then","res","text","data","console","info","ipRegex","match","rawParams","hasOwnProperty","userIP","address","state","isPublic","comment","publicState","hosts","ipClassContainer","document","querySelector","ipPublicContainer","hostsContainer","textContent","addressName","parent","firstChild","removeChild","populateWithoutSplit","affectedFromIndex","container","splitOctet","status","isAffected","octetElement","createElement","classesToAdd","classList","add","octetText","createTextNode","appendChild","containerElement","isPopulatingBinary","log","isSplitted","bitElement","bitText","populateWithSplit","name","entry","maskElement","charsOffset","transformStyles","style","transform","updateUIMaskPosition","ipAddr","maskAddr","ipSpan","maskSpan","innerHTML","calculatedData","e","alert","message","calculateAndUpdateUI"],"mappings":"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","file":"calculator.d549d13aad3d0931eaae.bundle.js","sourcesContent":["import IP from \"../../interfaces/IP\";\n\nconst getIPClass = (ip: IP): \"A\" | \"B\" | \"C\" | \"D\" | \"E\" => {\n  const firstOctetDec = ip.decimal.octets[0];\n  if (firstOctetDec <= 127) return \"A\";\n  if (firstOctetDec <= 191) return \"B\";\n  if (firstOctetDec <= 223) return \"C\";\n  if (firstOctetDec <= 239) return \"D\";\n  if (firstOctetDec <= 255) return \"E\";\n};\n\nexport default getIPClass;\n","const binToDec = (bin: string): number => {\n  return parseInt(bin, 2);\n};\n\nexport default binToDec;\n","import Mask from \"../../interfaces/Mask\";\n\nconst getAffectedOctetsIndexFromMask = (mask: Mask): number => {\n  const bits = mask.bits;\n  if (bits < 8) return 0;\n  if (bits >= 8 && bits < 16) return 1;\n  if (bits >= 16 && bits < 24) return 2;\n  if (bits >= 24) return 3;\n};\n\nexport default getAffectedOctetsIndexFromMask;\n","const nearestMultiple = (num: number, multiple: number): number => {\n  return Math.ceil(num / multiple) * multiple;\n};\n\nexport default nearestMultiple;\n","import IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport binToDec from \"../converters/binToDec\";\nimport getAffectedOctetsIndexFromMask from \"../getters/getAffectedOctetsIndexFromMask\";\nimport nearestMultiple from \"./nearestMultiple\";\n\nconst modifyIPViaMask = (ip: IP, mask: Mask, modifyWithBit: \"0\" | \"1\"): IP => {\n  const ipObject: IP = {\n    binary: {\n      octets: null,\n      string: null,\n    },\n    decimal: {\n      octets: null,\n      string: null,\n    },\n  };\n  const affectedOctetsFromIndex = getAffectedOctetsIndexFromMask(mask);\n  // console.log(\"from index (including)\", affectedOctetsFromIndex);\n  const affectedOctetsBin = ip.binary.octets.filter((_o, i) => i >= affectedOctetsFromIndex);\n  // const affectedOctets = ip.decimal.octets.filter((_o, i) => i >= affectedOctetsFromIndex);\n  // console.log(\"aff\", affectedOctets);\n  const closestOctetEnd = nearestMultiple(mask.bits, 8);\n  const affectedSinceBit = closestOctetEnd - mask.bits === 0 ? 0 : 8 - (closestOctetEnd - mask.bits);\n  // console.log(affectedSinceBit);\n  const affectedOctetsBinWithChanges = affectedOctetsBin.map((octet, index) => {\n    if (index === 0) {\n      //we split octet into an array of bits\n      const octetAsArray = octet.split(\"\");\n      //for every bit we check if it's index is within \"affected\" range if so we change it to \"1\" else we leave it as it is\n      const changedOctetAsArray = octetAsArray.map((bit, index) => {\n        if (index < affectedSinceBit) return bit;\n        return modifyWithBit;\n      });\n      //now that we have an array of bits that represent our octet with changes we can \"reassemble\" it back with .join()\n      return changedOctetAsArray.join(\"\");\n    }\n    //if it's not the first affected octet (means it'll just be all 1's or 0's) we return string \"11111111\"\n    return modifyWithBit.repeat(8);\n  });\n  //now that we have our new octets with changes and we know from which index whose octets start we can do a combination of our old\n  //octets and our new ones by replacing octets that are affected in original with the newly calculated ones\n  const unchangedOctets = ip.binary.octets.filter((_o, i) => i < affectedOctetsFromIndex);\n  const octetsWithChanges = unchangedOctets.concat(affectedOctetsBinWithChanges);\n  const octetsWithChangesDec = octetsWithChanges.map((octet) => binToDec(octet));\n  const octetsWithChangesString = octetsWithChanges.join(\".\");\n  const octetsWithChangesDecString = octetsWithChangesDec.join(\".\");\n\n  ipObject.binary.octets = octetsWithChanges;\n  ipObject.binary.string = octetsWithChangesString;\n  ipObject.decimal.octets = octetsWithChangesDec;\n  ipObject.decimal.string = octetsWithChangesDecString;\n\n  return ipObject;\n};\n\nexport default modifyIPViaMask;\n","import IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport modifyIPViaMask from \"./modifyIPViaMask\";\n\nconst calculateBroadcastAddress = (ip: IP, mask: Mask): IP => {\n  const broadcastAddress = modifyIPViaMask(ip, mask, \"1\");\n  return broadcastAddress;\n};\n\nexport default calculateBroadcastAddress;\n","import Mask from \"../../interfaces/Mask\";\n\nconst calculateHosts = (mask: Mask): number => {\n  if (mask.bits === 32 || mask.bits === 31) return 0; //32 is single-host and 31 is point-to-point\n  const amount = 2 ** (32 - mask.bits) - 2;\n  return amount;\n};\n\nexport default calculateHosts;\n","import IP from \"../../interfaces/IP\";\nimport binToDec from \"../converters/binToDec\";\n\n//referenceAddress is broadcast in case of max and network in case of min\nconst calculateMinMaxHostAddress = (referenceAddress: IP, type: \"min\" | \"max\"): IP => {\n  const ipObject: IP = {\n    binary: {\n      octets: null,\n      string: null,\n    },\n    decimal: {\n      octets: null,\n      string: null,\n    },\n  };\n  ipObject.binary.octets = [...referenceAddress.binary.octets];\n  const lastOctet = ipObject.binary.octets[3];\n  const lastOctetAsArray = lastOctet.split(\"\");\n  lastOctetAsArray[7] = type === \"max\" ? \"0\" : \"1\";\n  const lastOctetWithChanges = lastOctetAsArray.join(\"\");\n  ipObject.binary.octets[3] = lastOctetWithChanges;\n\n  ipObject.binary.string = ipObject.binary.octets.join(\".\");\n  ipObject.decimal.octets = ipObject.binary.octets.map((o) => binToDec(o));\n  ipObject.decimal.string = ipObject.decimal.octets.join(\".\");\n  return ipObject;\n};\n\nexport default calculateMinMaxHostAddress;\n","import IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport modifyIPViaMask from \"./modifyIPViaMask\";\n\nconst calculateNetworkAddress = (ip: IP, mask: Mask): IP => {\n  return modifyIPViaMask(ip, mask, \"0\");\n};\n\nexport default calculateNetworkAddress;\n","import IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport UIData from \"../../interfaces/UIData\";\nimport getIPClass from \"../getters/getIPClass\";\nimport calculateBroadcastAddress from \"./calculateBroadcastAddress\";\nimport calculateHosts from \"./calculateHosts\";\nimport calculateMinMaxHostAddress from \"./calculateLastHostAddress\";\nimport calculateNetworkAddress from \"./calculateNetworkAddress\";\n\nfunction calculateData(ip: IP, mask: Mask): UIData {\n  const broadcast = calculateBroadcastAddress(ip, mask);\n  const network = calculateNetworkAddress(ip, mask);\n  const hosts = calculateHosts(mask);\n  const ipClass = getIPClass(ip);\n  const maxHost = calculateMinMaxHostAddress(broadcast, \"max\");\n  const minHost = calculateMinMaxHostAddress(network, \"min\");\n\n  const data: UIData = {\n    ip,\n    mask,\n    network,\n    broadcast,\n    amountOfHosts: hosts,\n    ipClass,\n    maxHost,\n    minHost,\n  };\n\n  return data;\n}\n\nexport default calculateData;\n","import IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport MaskValidity from \"../../interfaces/MaskValidity\";\n\nconst checkMaskToIPValidity = (ip: IP, mask: Mask): MaskValidity => {\n  const validity: MaskValidity = {\n    valid: true,\n    reason: null,\n  };\n  const firstOctetDec = ip.decimal.octets[0];\n  const maskBits = mask.bits;\n\n  if (firstOctetDec >= 1 && firstOctetDec <= 127 && maskBits < 8) {\n    validity.valid = false;\n    validity.reason = `IP Mask [${maskBits}] is too big for address [${ip.decimal.string}]. Use /8 and smaller (higher amount of bits)`;\n    return validity;\n  }\n  if (firstOctetDec >= 128 && firstOctetDec <= 191 && maskBits < 16) {\n    validity.valid = false;\n    validity.reason = `IP Mask [${maskBits}] is too big for address [${ip.decimal.string}]. Use /16 and smaller (higher amount of bits)`;\n    return validity;\n  }\n  if (firstOctetDec >= 192 && firstOctetDec <= 223 && maskBits < 24) {\n    validity.valid = false;\n    validity.reason = `IP Mask [${maskBits}] is too big for address [${ip.decimal.string}]. Use /24 and smaller (higher amount of bits)`;\n    return validity;\n  }\n\n  return validity;\n};\n\nexport default checkMaskToIPValidity;\n","const decToBin = (dec: number): string => {\n  return dec.toString(2);\n};\n\nexport default decToBin;\n","import IP from \"../../interfaces/IP\";\nimport decToBin from \"../converters/decToBin\";\n\nconst parseIP = async (ipString: string): Promise<IP> => {\n  //split ip into octets\n  const rawIpOctets = ipString.split(\".\");\n  const ipOctets = rawIpOctets.map((octet) => Number(octet));\n  //check if ip is right\n  checkForErrors(ipOctets, rawIpOctets);\n  //if no errors are thrown in function above ip is correct and we can proceed\n  const ipOctetsBin = ipOctets.map((octet) => {\n    const octetBin = decToBin(octet);\n    const octetBinFormatted = octetBin.padStart(8, \"0\");\n    return octetBinFormatted;\n  });\n  return {\n    decimal: {\n      string: ipOctets.join(\".\"),\n      octets: ipOctets,\n    },\n    binary: {\n      string: ipOctetsBin.join(\".\"),\n      octets: ipOctetsBin,\n    },\n  };\n};\n\nconst checkForErrors = (ipOctets: number[], rawIpOctets: string[]) => {\n  let errorString = \"\";\n  ipOctets.map((octet, index) => {\n    if (Number.isNaN(octet)) {\n      errorString = `Incorrect value [${rawIpOctets[index]}] in octet #${index + 1}. | Value is not a number`;\n    }\n    if (octet > 255) {\n      errorString = `Incorrect value [${rawIpOctets[index]}] in octet #${index + 1}. | Value is above 255`;\n    }\n    if (octet < 0) {\n      errorString = `Incorrect value [${rawIpOctets[index]}] in octet #${index + 1}. | Value is less than 0`;\n    }\n  });\n  if (!!errorString) {\n    throw new Error(`Error while parsing IP: ${rawIpOctets.join(\".\")} | Error: ${errorString}`);\n  }\n};\n\nexport default parseIP;\n","//NOT MINE, JOINKED FROM STACKOVERFLOW\ninterface IResult {\n  [key: string]: string | string[];\n}\n\nfunction parseURLParams(url?: string) {\n  if (!url) url = location.href;\n  var question = url.indexOf(\"?\");\n  var hash = url.indexOf(\"#\");\n  if (hash == -1 && question == -1) return {};\n  if (hash == -1) hash = url.length;\n  var query = question == -1 || hash == question + 1 ? url.substring(hash) : url.substring(question + 1, hash);\n  var result: IResult = {};\n  query.split(\"&\").forEach(function (part) {\n    if (!part) return;\n    part = part.split(\"+\").join(\" \"); // replace every + with space, regexp-free version\n    var eq = part.indexOf(\"=\");\n    var key = eq > -1 ? part.substr(0, eq) : part;\n    var val = eq > -1 ? decodeURIComponent(part.substr(eq + 1)) : \"\";\n    var from = key.indexOf(\"[\");\n    if (from == -1) result[decodeURIComponent(key)] = val;\n    else {\n      var to = key.indexOf(\"]\", from);\n      var index = decodeURIComponent(key.substring(from + 1, to));\n      key = decodeURIComponent(key.substring(0, from));\n      if (!result[key]) result[key] = [];\n      if (!index) (result[key] as string[]).push(val);\n      else (result as any)[key][index] = val;\n    }\n  });\n  return result;\n}\n\nexport default parseURLParams;\n","const getMaskFromBits = (bits: number) => {\n  checkForErrors(bits);\n  switch (bits) {\n    case 0:\n      return \"0.0.0.0\";\n    case 1:\n      return \"128.0.0.0\";\n    case 2:\n      return \"192.0.0.0\";\n    case 3:\n      return \"224.0.0.0\";\n    case 4:\n      return \"240.0.0.0\";\n    case 5:\n      return \"248.0.0.0\";\n    case 6:\n      return \"252.0.0.0\";\n    case 7:\n      return \"254.0.0.0\";\n    case 8:\n      return \"255.0.0.0\";\n    case 9:\n      return \"255.128.0.0\";\n    case 10:\n      return \"255.192.0.0\";\n    case 11:\n      return \"255.224.0.0\";\n    case 12:\n      return \"255.240.0.0\";\n    case 13:\n      return \"255.248.0.0\";\n    case 14:\n      return \"255.252.0.0\";\n    case 15:\n      return \"255.254.0.0\";\n    case 16:\n      return \"255.255.0.0\";\n    case 17:\n      return \"255.255.128.0\";\n    case 18:\n      return \"255.255.192.0\";\n    case 19:\n      return \"255.255.224.0\";\n    case 20:\n      return \"255.255.240.0\";\n    case 21:\n      return \"255.255.248.0\";\n    case 22:\n      return \"255.255.252.0\";\n    case 23:\n      return \"255.255.254.0\";\n    case 24:\n      return \"255.255.255.0\";\n    case 25:\n      return \"255.255.255.128\";\n    case 26:\n      return \"255.255.255.192\";\n    case 27:\n      return \"255.255.255.224\";\n    case 28:\n      return \"255.255.255.240\";\n    case 29:\n      return \"255.255.255.248\";\n    case 30:\n      return \"255.255.255.252\";\n    case 31:\n      return \"255.255.255.254\";\n    case 32:\n      return \"255.255.255.255\";\n  }\n};\n\nconst checkForErrors = (bits: number) => {\n  let errorString = \"\";\n  if (bits > 32) {\n    errorString = \"Incorrect amount of bits. Value is above 32\";\n  }\n  if (bits < 0) {\n    errorString = \"Incorrect amount of bits. Value is less than 0\";\n  }\n  if (!!errorString) {\n    throw new Error(`Error while parsing mask | Error: ${errorString}`);\n  }\n};\n\nexport default getMaskFromBits;\n","async function text(url: string) {\n  return fetch(url).then((res) => res.text());\n}\n\nconst getUserIP = async () => {\n  const data = await text(\"https://www.cloudflare.com/cdn-cgi/trace\");\n  console.info(\"Getting user ip...\");\n  let ipRegex = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/;\n  let ip = data.match(ipRegex)[0];\n  return ip;\n};\n\nexport default getUserIP;\n","import IP from \"../../interfaces/IP\";\nimport Params from \"../../interfaces/Params\";\nimport parseIP from \"../general/parseIP\";\nimport parseURLParams from \"../general/parseURLParams\";\nimport getMaskFromBits from \"./getMaskFromBits\";\nimport getUserIP from \"./getUserIP\";\n\nconst getParams = async (): Promise<Params> => {\n  const rawParams = parseURLParams();\n  //check if both parameters were passed\n  if (!rawParams.hasOwnProperty(\"ip\") || !rawParams.hasOwnProperty(\"mask\"))\n    throw new Error(\"Missing IP or MASK parameters\");\n  let ip: IP = null;\n  //if no ip is provided use user ip, otherwise parse given ip\n  if (rawParams.ip !== \"\") {\n    ip = await parseIP(rawParams.ip?.toString());\n  } else {\n    const userIP = await getUserIP();\n    ip = await parseIP(userIP);\n  }\n  //parse mask\n  const mask = await parseIP(getMaskFromBits(Number(rawParams.mask)));\n  //return parsed objects\n  return {\n    ip,\n    mask: {\n      ...mask,\n      bits: Number(rawParams.mask),\n    },\n  };\n};\n\nexport default getParams;\n","import IP from \"../../interfaces/IP\";\nimport PublicState from \"../../interfaces/PublicState\";\n\nfunction getAddressPublicState(address: IP): PublicState {\n  const state: PublicState = {\n    isPublic: true,\n    comment: \"Yes\",\n  };\n  if (address.decimal.octets[0] === 192 && address.decimal.octets[1] === 168) {\n    state.isPublic = false;\n    state.comment = \"No, Private network 192.168.x.x\";\n  }\n  if (address.decimal.octets[0] === 172 && address.decimal.octets[1] >= 16 && address.decimal.octets[1] <= 31) {\n    state.isPublic = false;\n    state.comment = \"No, Private network 172.16-31.x.x\";\n  }\n  if (address.decimal.octets[0] === 10) {\n    state.isPublic = false;\n    state.comment = \"No, Private network 10.x.x.x\";\n  }\n  if (address.decimal.octets[0] === 127) {\n    state.isPublic = false;\n    state.comment = \"No, Loopback network 127.x.x.x\";\n  }\n  return state;\n}\n\nexport default getAddressPublicState;\n","function updateAdditionalInfoUI(ipClass: string, publicState: string, hosts: number) {\n  const ipClassContainer = document.querySelector(\".address-entry--ip-class .address-value\");\n  const ipPublicContainer = document.querySelector(\".address-entry--is-public .address-value\");\n  const hostsContainer = document.querySelector(\".address-entry--hosts .address-value\");\n  ipClassContainer.textContent = ipClass;\n  ipPublicContainer.textContent = publicState;\n  hostsContainer.textContent = hosts.toString();\n}\n\nexport default updateAdditionalInfoUI;\n","import AddressUIName from \"../../interfaces/AddressUIName\";\n\ntype ContainerType = \"binary\" | \"decimal\";\n\nfunction getContainerForAddress(addressName: AddressUIName, type: ContainerType): HTMLElement {\n  switch (addressName) {\n    case \"ip\":\n      return document.querySelector(`.data-entry--binary .address-entry--binary-ip .address-value`);\n    case \"network\":\n      return document.querySelector(`.data-entry--${type} .address-entry--network .address-value`);\n    case \"broadcast\":\n      return document.querySelector(`.data-entry--${type} .address-entry--broadcast .address-value`);\n    case \"min-host\":\n      return document.querySelector(`.data-entry--${type} .address-entry--min-host .address-value`);\n    case \"max-host\":\n      return document.querySelector(`.data-entry--${type} .address-entry--max-host .address-value`);\n  }\n}\n\nexport default getContainerForAddress;\n","function removeAllChildNodes(parent: HTMLElement): void {\n  while (parent.firstChild) {\n    parent.removeChild(parent.firstChild);\n  }\n}\n\nexport default removeAllChildNodes;\n","import Mask from \"../../interfaces/Mask\";\nimport removeAllChildNodes from \"../general/removeAllChildNodes\";\nimport nearestMultiple from \"../calculations/nearestMultiple\";\nimport getAffectedOctetsIndexFromMask from \"../getters/getAffectedOctetsIndexFromMask\";\n\nfunction populateElementWithOctets(\n  mask: Mask,\n  containerElement: HTMLElement,\n  octets: Array<string | number>,\n  isPopulatingBinary = false\n) {\n  //clear any children within container element\n  removeAllChildNodes(containerElement);\n  //get the index of first octet that is affected\n  const affectedOctetsFromIndex = getAffectedOctetsIndexFromMask(mask);\n\n  if (!isPopulatingBinary) {\n    populateWithoutSplit(octets, affectedOctetsFromIndex, containerElement);\n    return;\n  }\n  const maskBits = mask.bits;\n  if (maskBits === 32) {\n    populateWithoutSplit(octets, 99, containerElement);\n    return;\n  }\n  if (maskBits === 8 || maskBits === 16 || maskBits === 24) {\n    populateWithoutSplit(octets, affectedOctetsFromIndex, containerElement, {\n      status: true,\n      index: affectedOctetsFromIndex,\n    });\n    return;\n  }\n\n  populateWithSplit(mask, octets, affectedOctetsFromIndex, containerElement);\n}\n\nfunction populateWithoutSplit(\n  octets: Array<string | number>,\n  affectedFromIndex: number,\n  container: HTMLElement,\n  splitOctet = { status: false, index: 0 }\n) {\n  octets.forEach((octet, index) => {\n    const isAffected = index >= affectedFromIndex;\n    const octetElement = document.createElement(\"div\");\n    let classesToAdd = [];\n    if (isAffected) classesToAdd.push(\"octet--affected\");\n    if (splitOctet.status && index === splitOctet.index) classesToAdd.push(\"octet--mask-split\");\n    classesToAdd.push(\"octet\");\n    octetElement.classList.add(...classesToAdd);\n    const octetText = document.createTextNode(octet.toString());\n\n    //place all the stuff together\n    octetElement.appendChild(octetText);\n    container.appendChild(octetElement);\n  });\n}\n\nfunction populateWithSplit(\n  mask: Mask,\n  octets: Array<string | number>,\n  affectedFromIndex: number,\n  container: HTMLElement\n) {\n  console.log(\"populateWithSplit()\");\n  octets.forEach((octet, index) => {\n    console.log(`Octets.forEach() => ${octet} [${index}]`);\n    const isAffected = index >= affectedFromIndex;\n    const isSplitted = index === affectedFromIndex;\n    const octetElement = document.createElement(\"div\");\n    const classesToAdd: string[] = [];\n    if (isAffected) classesToAdd.push(\"octet--affected\");\n    if (isSplitted) classesToAdd.push(\"octet--splitted\");\n    classesToAdd.push(\"octet\");\n    octetElement.classList.add(...classesToAdd);\n\n    if (!isSplitted) {\n      const octetText = document.createTextNode(octet.toString());\n\n      //place all the stuff together\n      octetElement.appendChild(octetText);\n      container.appendChild(octetElement);\n      return;\n    }\n\n    const bits = octet.toString().split(\"\");\n    const closestOctetEnd = nearestMultiple(mask.bits, 8);\n    const affectedSinceBit = closestOctetEnd - mask.bits === 0 ? 0 : 8 - (closestOctetEnd - mask.bits);\n    bits.forEach((bit, index) => {\n      const bitElement = document.createElement(\"div\");\n      const bitText = document.createTextNode(bit);\n      const isAffected = index >= affectedSinceBit;\n      const isSplitted = index === affectedSinceBit;\n      const classesToAdd: string[] = [];\n      if (isAffected) classesToAdd.push(\"bit--affected\");\n      if (isSplitted) classesToAdd.push(\"bit--splitted\");\n      classesToAdd.push(\"bit\");\n      bitElement.classList.add(...classesToAdd);\n\n      bitElement.appendChild(bitText);\n      octetElement.appendChild(bitElement);\n    });\n    container.appendChild(octetElement);\n  });\n}\n\nexport default populateElementWithOctets;\n","import AddressUIEntry from \"../../interfaces/AddressUIEntry\";\nimport IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport getContainerForAddress from \"../getters/getContainerForAddress\";\nimport populateElementWithOctets from \"./populateElementWithOctets\";\n\nfunction updateBinaryUI(ip: IP, mask: Mask, network: IP, broadcast: IP, minHost: IP, maxHost: IP) {\n  const entries: AddressUIEntry[] = [\n    {\n      name: \"ip\",\n      data: ip,\n    },\n    {\n      name: \"network\",\n      data: network,\n    },\n    {\n      name: \"broadcast\",\n      data: broadcast,\n    },\n    {\n      name: \"min-host\",\n      data: minHost,\n    },\n    {\n      name: \"max-host\",\n      data: maxHost,\n    },\n  ];\n  for (let entry of entries) {\n    const name = entry.name;\n    const containerElement = getContainerForAddress(name, \"binary\");\n    const address = entry.data;\n    populateElementWithOctets(mask, containerElement, address.binary.octets, true);\n  }\n  updateUIMaskPosition(mask.bits);\n}\n\nfunction updateUIMaskPosition(bits: number) {\n  const maskElement = document.querySelector(\".data-entry--binary .mask-split\") as HTMLElement;\n  let charsOffset = bits;\n  if (bits > 24) charsOffset += 3;\n  else if (bits > 16) charsOffset += 2;\n  else if (bits > 8) charsOffset += 1;\n\n  let transformStyles: string = null;\n  if (bits === 32) {\n    transformStyles = `translateX(calc(${charsOffset}ch + 1.25rem - 1px))`;\n  } else if (bits === 8 || bits === 16 || bits === 24) {\n    //mask is splitting octets\n    transformStyles = `translateX(calc(${charsOffset}ch + 1.25rem - 1px))`;\n  } else {\n    //mask is splitting bits inside one of the octets\n    transformStyles = `translateX(calc(${charsOffset}ch + 0.5rem - 1px))`;\n  }\n\n  maskElement.style.transform = transformStyles;\n}\n\nexport default updateBinaryUI;\n","import AddressUIEntry from \"../../interfaces/AddressUIEntry\";\nimport IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\nimport getContainerForAddress from \"../getters/getContainerForAddress\";\nimport populateElementWithOctets from \"./populateElementWithOctets\";\n\nfunction updateDecimalUI(mask: Mask, network: IP, broadcast: IP, minHost: IP, maxHost: IP) {\n  const entries: AddressUIEntry[] = [\n    {\n      name: \"network\",\n      data: network,\n    },\n    {\n      name: \"broadcast\",\n      data: broadcast,\n    },\n    {\n      name: \"min-host\",\n      data: minHost,\n    },\n    {\n      name: \"max-host\",\n      data: maxHost,\n    },\n  ];\n  for (let entry of entries) {\n    const name = entry.name;\n    const containerElement = getContainerForAddress(name, \"decimal\");\n    const address = entry.data;\n    populateElementWithOctets(mask, containerElement, address.decimal.octets);\n  }\n}\n\nexport default updateDecimalUI;\n","import IP from \"../../interfaces/IP\";\nimport Mask from \"../../interfaces/Mask\";\n\nconst updateEnteredDataUI = (ip: IP, mask: Mask): void => {\n  const ipAddr = ip.decimal.string;\n  const maskAddr = mask.decimal.string;\n  const ipSpan = document.querySelector(\".address-entry--ip .address-value\") as HTMLSpanElement;\n  const maskSpan = document.querySelector(\".address-entry--mask .address-value\") as HTMLSpanElement;\n\n  ipSpan.textContent = ipAddr;\n  maskSpan.innerHTML = `${maskAddr}<span class=\"address-bits\">/${mask.bits}</span>`;\n};\n\nexport default updateEnteredDataUI;\n","import UIData from \"../../interfaces/UIData\";\nimport getAddressPublicState from \"../getters/getAddressPublicState\";\nimport updateAdditionalInfoUI from \"./updateAdditionalInfoUI\";\nimport updateBinaryUI from \"./updateBinaryUI\";\nimport updateDecimalUI from \"./updateDecimalUI\";\nimport updateEnteredDataUI from \"./updateEnteredDataUI\";\n\nfunction updateUI(data: UIData) {\n  const { ip, mask, network, broadcast, minHost, maxHost, amountOfHosts, ipClass } = data;\n  updateEnteredDataUI(ip, mask);\n  updateDecimalUI(mask, network, broadcast, minHost, maxHost);\n  updateBinaryUI(ip, mask, network, broadcast, minHost, maxHost);\n  updateAdditionalInfoUI(ipClass, getAddressPublicState(ip).comment, amountOfHosts);\n}\n\nexport default updateUI;\n","import \"../scss/main.scss\";\nimport IP from \"./interfaces/IP\";\nimport Mask from \"./interfaces/Mask\";\nimport calculateData from \"./utils/calculations/calculateData\";\nimport checkMaskToIPValidity from \"./utils/general/checkMaskToIPValidity\";\nimport getParams from \"./utils/getters/getParams\";\nimport updateUI from \"./utils/ui/updateUI\";\n\nconst main = async () => {\n  try {\n    const { ip, mask } = await getParams();\n    calculateAndUpdateUI(ip, mask);\n  } catch (e) {\n    alert(e.message);\n  }\n};\n\nfunction calculateAndUpdateUI(ip: IP, mask: Mask) {\n  try {\n    const validity = checkMaskToIPValidity(ip, mask);\n    if (!validity.valid) throw new Error(validity.reason);\n    //show selected ip and mask in form input\n    const calculatedData = calculateData(ip, mask);\n    updateUI(calculatedData);\n  } catch (e) {\n    alert(e.message);\n  }\n}\n\nmain();\n"],"sourceRoot":""}